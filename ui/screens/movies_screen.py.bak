import customtkinter as ctk
from typing import List, Dict, Callable, Optional
import os
import json
from pathlib import Path
import threading
import requests
from PIL import Image, ImageTk
from io import BytesIO
import datetime
import webbrowser
from movie_fetcher import MovieFetcher
from word_handler import WordHandler
from tkcalendar import Calendar, DateEntry

class MoviesScreen(ctk.CTkFrame):
    """
    Movies screen for the application.
    Displays a clean search interface for finding and adding movies.
    """
    
    def __init__(self, master, **kwargs):
        super().__init__(master, fg_color="transparent", **kwargs)
        
        # Initialize variables
        self.movies_data = []
        self.movie_fetcher = MovieFetcher()
        self.word_handler = WordHandler()
        self.current_details_frame = None
        
        # Load movie data
        self.data_file = Path("data/movies.json")
        self._load_movies()
        
        # Create UI
        self._create_ui()
    
    def _create_ui(self):
        """Create the UI elements for the movies screen"""
        # Configure grid
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)
        
        # Header frame
        self.header_frame = ctk.CTkFrame(self)
        self.header_frame.grid(row=0, column=0, sticky="ew", padx=20, pady=(0, 20))
        
        # Header title
        self.title_label = ctk.CTkLabel(
            self.header_frame,
            text="üé¨ Movies",
            font=ctk.CTkFont(size=28, weight="bold")
        )
        self.title_label.pack(side="left", padx=10, pady=10)
        
        # Search frame with icon
        self.search_frame = ctk.CTkFrame(
            self.header_frame,
            fg_color=("#f0f0f0", "#333333"),
            corner_radius=8
        )
        self.search_frame.pack(side="right", padx=10, pady=10, fill="x", expand=True)
        
        # Search icon
        self.search_icon = ctk.CTkLabel(
            self.search_frame,
            text="üîç",
            font=ctk.CTkFont(size=16),
            width=20
        )
        self.search_icon.pack(side="left", padx=(10, 0))
        
        # Search entry
        self.search_entry = ctk.CTkEntry(
            self.search_frame,
            placeholder_text="Search movies...",
            border_width=0,
            fg_color="transparent"
        )
        self.search_entry.pack(side="left", padx=5, pady=5, fill="x", expand=True)
        self.search_entry.bind("<Return>", self._on_search)
        
        # Content frame with search results
        self.content_frame = ctk.CTkScrollableFrame(self)
        self.content_frame.grid(row=1, column=0, sticky="nsew", padx=20, pady=(0, 20))
        self.content_frame.grid_columnconfigure(0, weight=1)
        
        # Welcome message
        self.welcome_frame = ctk.CTkFrame(self.content_frame, fg_color="transparent")
        self.welcome_frame.pack(fill="both", expand=True, padx=20, pady=50)
        
        welcome_icon = ctk.CTkLabel(
            self.welcome_frame,
            text="üé¨",
            font=ctk.CTkFont(size=48)
        )
        welcome_icon.pack(pady=(0, 10))
        
        welcome_text = ctk.CTkLabel(
            self.welcome_frame,
            text="Search for movies to add to your collection",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        welcome_text.pack(pady=5)
        
        instruction_text = ctk.CTkLabel(
            self.welcome_frame,
            text="Type a movie name in the search box and press Enter",
            font=ctk.CTkFont(size=14),
            text_color="gray70"
        )
        instruction_text.pack(pady=5)
        
        # Back to results button (hidden initially)
        self.back_button = ctk.CTkButton(
            self,
            text="‚Üê Back to Results",
            command=self._back_to_results,
            width=150,
            fg_color=("#4a86e8", "#2d5bb9"),
            hover_color=("#3a76d8", "#1d4ba9")
        )
        # Don't grid it yet - will be shown when needed
        
        # Movie details container (hidden initially)
        self.details_container = ctk.CTkFrame(self, fg_color="transparent")
        # Don't grid it yet - will be shown when needed
    
    def _load_movies(self):
        """Load movies from the data file"""
        try:
            if self.data_file.exists():
                with open(self.data_file, "r") as f:
                    self.movies_data = json.load(f)
            else:
                # Create directory if it doesn't exist
                self.data_file.parent.mkdir(parents=True, exist_ok=True)
                # Create empty file
                with open(self.data_file, "w") as f:
                    json.dump([], f)
                self.movies_data = []
        except Exception as e:
            print(f"Error loading movies: {e}")
            self.movies_data = []
    
    def _save_movies(self):
        """Save movies to the data file"""
        try:
            # Create directory if it doesn't exist
            self.data_file.parent.mkdir(parents=True, exist_ok=True)
            
            with open(self.data_file, "w") as f:
                json.dump(self.movies_data, f, indent=2)
        except Exception as e:
            print(f"Error saving movies: {e}")
    
    def _on_search(self, event):
        """Handle search when Enter is pressed"""
        search_text = self.search_entry.get().strip()
        if not search_text:
            return
            
        # Clear previous content
        for widget in self.content_frame.winfo_children():
                widget.destroy()
        
        # Show loading indicator
        loading_frame = ctk.CTkFrame(self.content_frame, fg_color="transparent")
        loading_frame.pack(fill="both", expand=True, padx=20, pady=50)
        
        loading_label = ctk.CTkLabel(
            loading_frame,
            text=f"Searching for '{search_text}'...",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        loading_label.pack(pady=10)
        
        # Search online
        def search_movies():
            try:
                # Search online
                api_results = self.movie_fetcher.search_media(search_text, "movie")
                
                # Process and display results
                self.after(0, lambda: self._display_search_results(api_results, search_text))
            except Exception as e:
                print(f"Error searching online: {e}")
                self.after(0, lambda: self._show_search_error(str(e)))
                
        # Start the search in a separate thread
        threading.Thread(target=search_movies).start()
    
    def _display_search_results(self, results, search_query):
        """Display search results with thumbnails"""
        # Clear previous content
        for widget in self.content_frame.winfo_children():
            widget.destroy()
        
        # If we have no results
        if not results:
            empty_frame = ctk.CTkFrame(self.content_frame, fg_color="transparent")
            empty_frame.pack(fill="both", expand=True, padx=20, pady=50)
            
            empty_label = ctk.CTkLabel(
                empty_frame,
                text=f"No movies found for '{search_query}'",
                font=ctk.CTkFont(size=18, weight="bold")
            )
            empty_label.pack(pady=10)
            
            suggestion_label = ctk.CTkLabel(
                empty_frame,
                text="Try a different search term",
                font=ctk.CTkFont(size=14),
                text_color="gray70"
            )
            suggestion_label.pack(pady=5)
            return
        
        # Results heading
        results_label = ctk.CTkLabel(
            self.content_frame,
            text=f"Search Results ({len(results)} found):",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        results_label.pack(anchor="w", padx=20, pady=(20, 10))
        
        # Results grid
        results_grid = ctk.CTkFrame(self.content_frame, fg_color="transparent")
        results_grid.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Create a movie card for each result
        for i, movie in enumerate(results):
            self._create_movie_result_card(results_grid, movie, i)
    
    def _create_movie_result_card(self, parent, movie, index):
        """Create a card for a movie search result"""
        # Card frame
        card = ctk.CTkFrame(
            parent, 
            corner_radius=10,
            border_width=1,
            border_color=("lightgray", "gray30")
        )
        card.pack(fill="x", padx=10, pady=5)
        
        # Make the entire card clickable
        card.bind("<Button-1>", lambda e, m=movie: self._show_movie_details(m))
        
        # Configure grid
        card.grid_columnconfigure(1, weight=1)
        
        # Movie poster frame
        poster_frame = ctk.CTkFrame(
            card, 
            width=90, 
            height=135,
            fg_color=("gray90", "gray20")
        )
        poster_frame.grid(row=0, column=0, padx=10, pady=10)
        poster_frame.bind("<Button-1>", lambda e, m=movie: self._show_movie_details(m))
        
        # If movie has poster URL, load it
        poster_url = f"https://image.tmdb.org/t/p/w185{movie.get('poster_path')}" if movie.get('poster_path') else None
        if poster_url:
            self._load_movie_poster(poster_url, poster_frame)
        else:
            # Placeholder text
            poster_label = ctk.CTkLabel(
                poster_frame, 
                text="üé¨",
                font=ctk.CTkFont(size=32)
            )
            poster_label.place(relx=0.5, rely=0.5, anchor="center")
            poster_label.bind("<Button-1>", lambda e, m=movie: self._show_movie_details(m))
        
        # Movie details
        details_frame = ctk.CTkFrame(card, fg_color="transparent")
        details_frame.grid(row=0, column=1, sticky="nsew", padx=10, pady=10)
        details_frame.bind("<Button-1>", lambda e, m=movie: self._show_movie_details(m))
        
        # Title and year
        title = movie.get("title", "Unknown")
        year = movie.get("release_date", "")[:4] if movie.get("release_date") else ""
        
        title_year = f"{title}"
        if year:
            title_year += f" ({year})"
            
        title_label = ctk.CTkLabel(
            details_frame,
            text=title_year,
            font=ctk.CTkFont(size=18, weight="bold"),
            anchor="w"
        )
        title_label.pack(anchor="w")
        title_label.bind("<Button-1>", lambda e, m=movie: self._show_movie_details(m))
        
        # Overview/description (truncated)
        overview = movie.get("overview", "")
        if overview:
            if len(overview) > 150:
                overview = overview[:150] + "..."
                
            overview_label = ctk.CTkLabel(
                details_frame,
                text=overview,
                font=ctk.CTkFont(size=12),
                text_color=("gray40", "gray70"),
                anchor="w",
                wraplength=400,
                justify="left"
            )
            overview_label.pack(anchor="w", pady=(5, 0))
            overview_label.bind("<Button-1>", lambda e, m=movie: self._show_movie_details(m))
        
        # Change button to "View Details" to better indicate functionality
        select_button = ctk.CTkButton(
            details_frame,
            text="View Details",
            width=120,
            height=32,
            corner_radius=8,
            font=ctk.CTkFont(weight="bold"),
            fg_color=("#4a86e8", "#2d5bb9"),
            hover_color=("#3a76d8", "#1d4ba9"),
            command=lambda: self._show_movie_details(movie)
        )
        select_button.pack(anchor="e", pady=(10, 0))
    
    def _load_movie_poster(self, url, frame, size=(90, 135)):
        """Load movie poster from URL in a separate thread"""
        # Create a flag to track if the frame is destroyed
        frame_alive = True
        frame._poster_loading = True  # Mark this frame as loading a poster
        
        def check_frame_exists():
            # This needs to be called from the main thread
            nonlocal frame_alive
            try:
                frame.winfo_exists()  # Will raise TclError if destroyed
                return True
            except Exception:
                frame_alive = False
                return False
        
        def load_image():
            try:
                response = requests.get(url, timeout=10)
                img_data = BytesIO(response.content)
                img = Image.open(img_data)
                img = img.resize(size, Image.LANCZOS)
                
                # Schedule the UI update on the main thread
                def update_ui():
                    if check_frame_exists():
                        try:
                            # Use CTkImage
                            ctk_img = ctk.CTkImage(light_image=img, dark_image=img, size=size)
                            
                            # Create label with CTkImage
                            img_label = ctk.CTkLabel(frame, text="", image=ctk_img)
                            img_label.place(relx=0.5, rely=0.5, anchor="center")
                            
                            # Keep a reference to prevent garbage collection
                            if not hasattr(frame, "_image_refs"):
                                frame._image_refs = []
                            frame._image_refs.append(ctk_img)
                        except Exception as e:
                            print(f"Error updating UI with image: {e}")
                
                # Schedule UI update on main thread
                self.after(0, update_ui)
                
            except Exception as e:
                print(f"Error loading image: {e}")
                
                # Schedule showing placeholder on main thread
                def show_placeholder():
                    if check_frame_exists():
                        try:
                            # Show placeholder on error
                            placeholder = ctk.CTkLabel(
                                frame, 
                                text="üé¨",
                                font=ctk.CTkFont(size=32 if size[0] < 100 else 64)
                            )
                            placeholder.place(relx=0.5, rely=0.5, anchor="center")
                        except Exception as placeholder_error:
                            print(f"Error creating placeholder: {placeholder_error}")
                
                self.after(0, show_placeholder)
        
        # Start thread to load image
        threading.Thread(target=load_image).start()
    
    def _show_movie_details(self, movie):
        """Show the movie details in an expanded view"""
        # First fetch full details
        movie_id = movie.get("id")
        if not movie_id:
            self._show_error("Could not fetch movie details")
            return
            
        # Show loading dialog
        loading_dialog = ctk.CTkToplevel(self)
        loading_dialog.title("Fetching Details")
        loading_dialog.geometry("300x100")
        loading_dialog.resizable(False, False)
        loading_dialog.transient(self)
        loading_dialog.grab_set()
        
        # Center dialog
        loading_dialog.update_idletasks()
        x = self.winfo_rootx() + (self.winfo_width() - loading_dialog.winfo_width()) // 2
        y = self.winfo_rooty() + (self.winfo_height() - loading_dialog.winfo_height()) // 2
        loading_dialog.geometry(f"+{x}+{y}")
        
        loading_label = ctk.CTkLabel(
            loading_dialog,
            text=f"Fetching details for\n{movie.get('title', 'movie')}...",
            font=ctk.CTkFont(size=14)
        )
        loading_label.pack(expand=True, fill="both", padx=20, pady=20)
        
        def fetch_details():
            try:
                details = self.movie_fetcher.get_movie_details(movie_id)
                self.after(0, lambda: self._display_movie_details(loading_dialog, movie, details))
            except Exception as e:
                self.after(0, lambda: self._show_error(f"Error fetching movie details: {e}"))
                self.after(0, loading_dialog.destroy)
        
        # Start the fetch in a separate thread
        threading.Thread(target=fetch_details).start()
    
    def _display_movie_details(self, loading_dialog, movie, details):
        """Display detailed movie information in the main content area"""
        loading_dialog.destroy()
        
        # Save the current search results
        self.last_search_results = []
        for widget in self.content_frame.winfo_children():
            self.last_search_results.append(widget)
            widget.pack_forget()  # Hide but don't destroy
        
        # Add back button at the top of the content frame
        back_frame = ctk.CTkFrame(self.content_frame, fg_color="transparent")
        back_frame.pack(fill="x", padx=0, pady=(0, 10))
        
        back_button = ctk.CTkButton(
            back_frame,
            text="‚Üê Back to Results",
            command=self._back_to_results,
            width=150,
                fg_color=("#4a86e8", "#2d5bb9"),
            hover_color=("#3a76d8", "#1d4ba9")
        )
        back_button.pack(side="left")
        
        # Create detail view container
        detail_view = ctk.CTkFrame(self.content_frame, fg_color="transparent")
        detail_view.pack(fill="both", expand=True)
        
        # Create two columns
        left_column = ctk.CTkFrame(detail_view, fg_color="transparent")
        left_column.pack(side="left", fill="both", padx=(0, 20))
        
        right_column = ctk.CTkFrame(detail_view, fg_color="transparent")
        right_column.pack(side="left", fill="both", expand=True)
        
        # Poster frame in left column
        poster_frame = ctk.CTkFrame(
            left_column, 
            width=300, 
            height=450,
            fg_color=("gray90", "gray20")
        )
        poster_frame.pack(padx=10, pady=10)
        
        # If movie has poster URL, load it with higher resolution
        poster_url = f"https://image.tmdb.org/t/p/w500{movie.get('poster_path')}" if movie.get('poster_path') else None
        if poster_url:
            self._load_movie_poster(poster_url, poster_frame, size=(300, 450))
        else:
            # Placeholder text
            poster_label = ctk.CTkLabel(
                poster_frame, 
                text="üé¨",
                font=ctk.CTkFont(size=64)
            )
            poster_label.place(relx=0.5, rely=0.5, anchor="center")
        
        # Action buttons
        action_frame = ctk.CTkFrame(left_column, fg_color="transparent")
        action_frame.pack(fill="x", padx=10, pady=10)
        
        add_button = ctk.CTkButton(
            action_frame,
            text="Add to Collection",
            command=lambda: self._show_movie_add_dialog(None, movie, details),
            height=40,
            font=ctk.CTkFont(size=14, weight="bold")
        )
        add_button.pack(fill="x", padx=5, pady=5)
        
        # IMDb link if available
        if "imdb_id" in details and details["imdb_id"]:
            imdb_button = ctk.CTkButton(
                action_frame,
                text="Visit IMDb Page",
                command=lambda: webbrowser.open(f"https://www.imdb.com/title/{details['imdb_id']}"),
                fg_color="#f5c518",
                text_color="black",
                hover_color="#d4a700",
                height=40,
                font=ctk.CTkFont(size=14, weight="bold")
            )
            imdb_button.pack(fill="x", padx=5, pady=5)
        
        # Movie details in right column
        # Title and year
        title = movie.get("title", "Unknown")
        year = movie.get("release_date", "")[:4] if movie.get("release_date") else ""
        
        title_text = title
        if year:
            title_text += f" ({year})"
            
        title_label = ctk.CTkLabel(
            right_column,
            text=title_text,
            font=ctk.CTkFont(size=24, weight="bold"),
            wraplength=500,
            justify="left"
        )
        title_label.pack(anchor="w", pady=(0, 10))
        
        # Tagline if available
        if "tagline" in details and details["tagline"]:
            tagline_label = ctk.CTkLabel(
                right_column,
                text=details["tagline"],
                font=ctk.CTkFont(size=16, slant="italic"),
                text_color=("gray40", "gray70")
            )
            tagline_label.pack(anchor="w", pady=(0, 15))
        
        # Ratings display
        if "imdb_rating" in details or "rt_rating" in details:
            ratings_frame = ctk.CTkFrame(right_column, fg_color="transparent")
            ratings_frame.pack(fill="x", pady=(0, 15))
            
            if "imdb_rating" in details and details["imdb_rating"]:
            imdb_frame = ctk.CTkFrame(
                ratings_frame,
                fg_color=("#f5c518", "#f5c518"),
                corner_radius=5
            )
            imdb_frame.pack(side="left", padx=(0, 10))
            
            imdb_label = ctk.CTkLabel(
                imdb_frame,
                    text=f"IMDb: {details['imdb_rating']}",
                    font=ctk.CTkFont(size=14, weight="bold"),
                text_color="black",
                padx=8,
                pady=2
            )
            imdb_label.pack()
        
            if "rt_rating" in details and details["rt_rating"]:
                rt_color = "#fa320a" if float(details["rt_rating"].replace("%", "")) >= 60 else "#76b900"
            rt_frame = ctk.CTkFrame(
                ratings_frame,
                fg_color=(rt_color, rt_color),
                corner_radius=5
            )
            rt_frame.pack(side="left")
            
            rt_label = ctk.CTkLabel(
                rt_frame,
                    text=f"RT: {details['rt_rating']}",
                    font=ctk.CTkFont(size=14, weight="bold"),
                text_color="white",
                padx=8,
                pady=2
            )
            rt_label.pack()
        
        # Info grid: runtime, genres, director, release date
        info_frame = ctk.CTkFrame(right_column, fg_color="transparent")
        info_frame.pack(fill="x", pady=(0, 15))
        info_frame.grid_columnconfigure(1, weight=1)
        
        # Runtime
        info_row = 0
        if "runtime" in details and details["runtime"]:
            runtime_label = ctk.CTkLabel(
                info_frame,
                text="Runtime:",
            font=ctk.CTkFont(weight="bold"),
                anchor="w"
            )
            runtime_label.grid(row=info_row, column=0, sticky="w", padx=(0, 10), pady=2)
            
            runtime_value = ctk.CTkLabel(
                info_frame,
                text=f"{details['runtime']} minutes",
                anchor="w"
            )
            runtime_value.grid(row=info_row, column=1, sticky="w", pady=2)
            info_row += 1
        
        # Genres
        if "genres" in details and details["genres"]:
            genres_label = ctk.CTkLabel(
                info_frame,
                text="Genres:",
            font=ctk.CTkFont(weight="bold"),
                anchor="w"
            )
            genres_label.grid(row=info_row, column=0, sticky="w", padx=(0, 10), pady=2)
            
            genres_value = ctk.CTkLabel(
                info_frame,
                text=details["genres"],
                anchor="w",
                wraplength=400,
                justify="left"
            )
            genres_value.grid(row=info_row, column=1, sticky="w", pady=2)
            info_row += 1
        
        # Director
        if "director" in details and details["director"]:
            director_label = ctk.CTkLabel(
                info_frame,
                text="Director:",
                font=ctk.CTkFont(weight="bold"),
                anchor="w"
            )
            director_label.grid(row=info_row, column=0, sticky="w", padx=(0, 10), pady=2)
            
            director_value = ctk.CTkLabel(
                info_frame,
                text=details["director"],
                anchor="w"
            )
            director_value.grid(row=info_row, column=1, sticky="w", pady=2)
            info_row += 1
        
        # Release date
        if "release_date" in details and details["release_date"]:
            release_label = ctk.CTkLabel(
                info_frame,
                text="Release Date:",
                font=ctk.CTkFont(weight="bold"),
                anchor="w"
            )
            release_label.grid(row=info_row, column=0, sticky="w", padx=(0, 10), pady=2)
            
            release_value = ctk.CTkLabel(
                info_frame,
                text=details["release_date"],
                anchor="w"
            )
            release_value.grid(row=info_row, column=1, sticky="w", pady=2)
            info_row += 1
        
        # Overview section
        if movie.get("overview"):
            overview_label = ctk.CTkLabel(
                right_column,
                text="Overview",
                font=ctk.CTkFont(size=18, weight="bold"),
                anchor="w"
            )
            overview_label.pack(anchor="w", pady=(0, 5))
            
            overview_text = ctk.CTkLabel(
                right_column,
                text=movie.get("overview"),
                anchor="w",
                wraplength=500,
                justify="left"
            )
            overview_text.pack(anchor="w", pady=(0, 15))
        
        # Cast section if available
        if "cast" in details and details["cast"]:
            cast_label = ctk.CTkLabel(
                right_column,
                text="Cast",
                font=ctk.CTkFont(size=18, weight="bold"),
                anchor="w"
            )
            cast_label.pack(anchor="w", pady=(0, 5))
            
            cast_text = ctk.CTkLabel(
                right_column,
                text=details["cast"],
                anchor="w",
                wraplength=500,
                justify="left"
            )
            cast_text.pack(anchor="w", pady=(0, 15))
    
    def _back_to_results(self):
        """Return to search results view"""
        # Clear the content frame
        for widget in self.content_frame.winfo_children():
            widget.destroy()
        
        # Add back the search results
        if hasattr(self, 'last_search_results') and self.last_search_results:
            for widget in self.last_search_results:
                widget.pack(fill="x", padx=10, pady=5)
        else:
            self._create_ui()  # Recreate the welcome view
    
    def _show_error(self, message):
        """Show an error message"""
        dialog = ctk.CTkInputDialog(
            text=message,
            title="Error"
        )
        dialog.get_input()
    
    def _show_search_error(self, error):
        """Show search error and reset to welcome screen"""
        self._show_error(f"Error searching: {error}")
        
        # Clear content frame and recreate welcome message
        for widget in self.content_frame.winfo_children():
            widget.destroy()
            
        self.welcome_frame = ctk.CTkFrame(self.content_frame, fg_color="transparent")
        self.welcome_frame.pack(fill="both", expand=True, padx=20, pady=50)
        
        welcome_icon = ctk.CTkLabel(
            self.welcome_frame,
            text="üé¨",
            font=ctk.CTkFont(size=48)
        )
        welcome_icon.pack(pady=(0, 10))
        
        welcome_text = ctk.CTkLabel(
            self.welcome_frame,
            text="Search for movies to add to your collection",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        welcome_text.pack(pady=5)
        
        instruction_text = ctk.CTkLabel(
            self.welcome_frame,
            text="Type a movie name in the search box and press Enter",
            font=ctk.CTkFont(size=14),
            text_color="gray70"
        )
        instruction_text.pack(pady=5)

    def _show_movie_add_dialog(self, loading_dialog, movie, details):
        """Show dialog to add movie with watch date and rating"""
        if loading_dialog:
            loading_dialog.destroy()
        
        dialog = MovieAddDialog(self, movie, details)
        dialog.wait_window()  # Wait for the dialog to close
        
        # If movie was added, refresh the view
        if hasattr(dialog, "result") and dialog.result:
            # Add the movie to data
            self.movies_data.append(dialog.result)
            self._save_movies()
            
            # Show success message
            success_msg = f"Added '{dialog.result.get('title')}' to your collection"
            if dialog.result.get("word_added", False):
                success_msg += " and Word document"
            
            self._show_message(success_msg, "Success")
            
            # Go back to results or welcome screen
            self._back_to_results()


class MovieAddDialog(ctk.CTkToplevel):
    """Dialog for adding a movie with watch date and rating"""
    
    def __init__(self, parent, movie, details):
        super().__init__(parent)
        self.title("Add Movie")
        self.geometry("600x650")  # Increased size to accommodate movie poster
        
        # Make the dialog modal
        self.transient(parent)
        self.grab_set()
        
        # Center the dialog on the parent
        self.update_idletasks()
        x = parent.winfo_rootx() + (parent.winfo_width() - self.winfo_width()) // 2
        y = parent.winfo_rooty() + (parent.winfo_height() - self.winfo_height()) // 2
        self.geometry(f"+{x}+{y}")
        
        # Store movie data
        self.movie = movie
        self.details = details
        self.parent = parent
        self.result = None
        self.saved_to_word = False
        
        # Initialize Word handler
        self.word_handler = WordHandler()
        
        # Create UI
        self._create_ui()
    
    def _create_ui(self):
        """Create UI for the add dialog"""
        # Main frame with padding
        main_frame = ctk.CTkScrollableFrame(self)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Create two columns
        left_column = ctk.CTkFrame(main_frame, fg_color="transparent")
        left_column.pack(side="left", fill="both", expand=True, padx=(0, 10))
        
        right_column = ctk.CTkFrame(main_frame, fg_color="transparent")
        right_column.pack(side="right", fill="both", expand=True, padx=(10, 0))
        
        # Poster frame in left column
        poster_frame = ctk.CTkFrame(
            left_column, 
            width=240, 
            height=360,
            fg_color=("gray90", "gray20")
        )
        poster_frame.pack(padx=10, pady=10, fill="both", expand=True)
        
        # If movie has poster URL, load it
        poster_url = f"https://image.tmdb.org/t/p/w500{self.movie.get('poster_path')}" if self.movie.get('poster_path') else None
        if poster_url:
            self._load_poster(poster_url, poster_frame)
        else:
            # Placeholder text
            poster_label = ctk.CTkLabel(
                poster_frame, 
                text="üé¨",
                font=ctk.CTkFont(size=64)
            )
            poster_label.place(relx=0.5, rely=0.5, anchor="center")
        
        # Movie details in right column
        # Header with movie info
        header_frame = ctk.CTkFrame(right_column)
        header_frame.pack(fill="x", padx=10, pady=(0, 20))
        
        # Movie title and year
        title = self.movie.get("title", "Unknown")
        year = self.movie.get("release_date", "")[:4] if self.movie.get("release_date") else ""
        
        title_text = title
        if year:
            title_text += f" ({year})"
            
        title_label = ctk.CTkLabel(
            header_frame,
            text=title_text,
            font=ctk.CTkFont(size=20, weight="bold")
        )
        title_label.pack(pady=(10, 0))
        
        # Movie details
        if "genres" in self.details:
            genre_label = ctk.CTkLabel(
                header_frame,
                text=self.details.get("genres", ""),
                font=ctk.CTkFont(size=14),
                text_color=("gray40", "gray70")
            )
            genre_label.pack(pady=(5, 0))
        
        # Runtime
        if "runtime" in self.details:
            runtime_label = ctk.CTkLabel(
                header_frame,
                text=f"{self.details.get('runtime', '')} minutes",
                font=ctk.CTkFont(size=14),
                text_color=("gray40", "gray70")
            )
            runtime_label.pack(pady=(5, 0))
        
        # Ratings display
        ratings_frame = ctk.CTkFrame(header_frame, fg_color="transparent")
        ratings_frame.pack(pady=(10, 10))
        
        if "imdb_rating" in self.details and self.details["imdb_rating"]:
            imdb_frame = ctk.CTkFrame(
                ratings_frame,
                fg_color=("#f5c518", "#f5c518"),
                corner_radius=5
            )
            imdb_frame.pack(side="left", padx=(0, 10))
            
            imdb_label = ctk.CTkLabel(
                imdb_frame,
                text=f"IMDb: {self.details['imdb_rating']}",
                font=ctk.CTkFont(size=14, weight="bold"),
                text_color="black",
                padx=8,
                pady=2
            )
            imdb_label.pack()
        
        if "rt_rating" in self.details and self.details["rt_rating"]:
            rt_color = "#fa320a" if float(self.details["rt_rating"].replace("%", "")) >= 60 else "#76b900"
            rt_frame = ctk.CTkFrame(
                ratings_frame,
                fg_color=(rt_color, rt_color),
                corner_radius=5
            )
            rt_frame.pack(side="left")
            
            rt_label = ctk.CTkLabel(
                rt_frame,
                text=f"RT: {self.details['rt_rating']}",
                font=ctk.CTkFont(size=14, weight="bold"),
                text_color="white",
                padx=8,
                pady=2
            )
            rt_label.pack()
        
        # Separator
        separator = ctk.CTkFrame(right_column, height=2, fg_color="gray70")
        separator.pack(fill="x", padx=10, pady=10)
        
        # Form section title
        form_title = ctk.CTkLabel(
            right_column,
            text="Add to Your Collection",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        form_title.pack(pady=(0, 10))
        
        # Watch date section
        date_frame = ctk.CTkFrame(right_column)
        date_frame.pack(fill="x", padx=10, pady=(0, 20))
        
        date_label = ctk.CTkLabel(
            date_frame,
            text="When did you watch this movie?",
            font=ctk.CTkFont(size=14, weight="bold")
        )
        date_label.pack(anchor="w", padx=10, pady=(10, 5))
        
        # Date options
        date_options_frame = ctk.CTkFrame(date_frame, fg_color="transparent")
        date_options_frame.pack(fill="x", padx=10, pady=(0, 10))
        
        # Today option
        self.date_var = ctk.StringVar(value="today")
        
        today_radio = ctk.CTkRadioButton(
            date_options_frame,
            text="Today",
            variable=self.date_var,
            value="today",
            command=self._toggle_date_option,
            fg_color="#4a86e8",  # Match app blue color
            hover_color="#2d5bb9"  # Darker blue for hover
        )
        today_radio.pack(anchor="w", padx=10, pady=5)
        
        # Custom date option
        custom_date_frame = ctk.CTkFrame(date_options_frame, fg_color="transparent")
        custom_date_frame.pack(fill="x", padx=10, pady=5)
        
        custom_radio = ctk.CTkRadioButton(
            custom_date_frame,
            text="Custom date:",
            variable=self.date_var,
            value="custom",
            command=self._toggle_date_option,
            fg_color="#4a86e8",  # Match app blue color
            hover_color="#2d5bb9"  # Darker blue for hover
        )
        custom_radio.pack(side="left", padx=(0, 10))
        
        # Date entry with app theme colors
        today = datetime.datetime.now()
        self.date_entry = DateEntry(
            custom_date_frame,
            width=12,
            background='#4a86e8',  # Match app blue color
            foreground='white',
            borderwidth=2,
            year=today.year,
            month=today.month,
            day=today.day,
            date_pattern='MM/dd/yyyy',
            state="disabled",
            selectbackground='#2d5bb9',  # Darker blue for selection
            selectforeground='white'
        )
        self.date_entry.pack(side="left", padx=5)
        
        # Rewatch section
        rewatch_frame = ctk.CTkFrame(right_column)
        rewatch_frame.pack(fill="x", padx=10, pady=(0, 20))
        
        rewatch_label = ctk.CTkLabel(
            rewatch_frame,
            text="Is this a rewatch?",
            font=ctk.CTkFont(size=14, weight="bold")
        )
        rewatch_label.pack(anchor="w", padx=10, pady=(10, 5))
        
        # Rewatch options
        rewatch_options_frame = ctk.CTkFrame(rewatch_frame, fg_color="transparent")
        rewatch_options_frame.pack(fill="x", padx=10, pady=(0, 10))
        
        self.rewatch_var = ctk.StringVar(value="no")
        
        no_radio = ctk.CTkRadioButton(
            rewatch_options_frame,
            text="No, first time watching",
            variable=self.rewatch_var,
            value="no",
            fg_color="#4a86e8",  # Match app blue color
            hover_color="#2d5bb9"  # Darker blue for hover
        )
        no_radio.pack(anchor="w", padx=10, pady=5)
        
        yes_radio = ctk.CTkRadioButton(
            rewatch_options_frame,
            text="Yes, I've seen it before",
            variable=self.rewatch_var,
            value="yes",
            fg_color="#4a86e8",  # Match app blue color
            hover_color="#2d5bb9"  # Darker blue for hover
        )
        yes_radio.pack(anchor="w", padx=10, pady=5)
        
        # Your rating section
        rating_frame = ctk.CTkFrame(right_column)
        rating_frame.pack(fill="x", padx=10, pady=(0, 20))
        
        rating_label = ctk.CTkLabel(
            rating_frame,
            text="Your Rating (1-10):",
            font=ctk.CTkFont(size=14, weight="bold")
        )
        rating_label.pack(anchor="w", padx=10, pady=(10, 5))
        
        # Rating slider
        self.rating_var = ctk.DoubleVar(value=8)
        self.rating_slider = ctk.CTkSlider(
            rating_frame,
            from_=1,
            to=10,
            number_of_steps=18,
            variable=self.rating_var,
            command=self._update_rating_label,
            progress_color="#4a86e8"  # Match app blue color
        )
        self.rating_slider.pack(fill="x", padx=20, pady=10)
        
        # Rating value label
        self.rating_label = ctk.CTkLabel(
            rating_frame,
            text="8.0",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        self.rating_label.pack(pady=(0, 10))
        
        # Buttons frame
        buttons_frame = ctk.CTkFrame(right_column, fg_color="transparent")
        buttons_frame.pack(fill="x", padx=10, pady=(20, 0))
        
        # Cancel button
        cancel_button = ctk.CTkButton(
            buttons_frame,
            text="Cancel",
            command=self.destroy,
            fg_color="gray",
            hover_color="darkgray",
            width=120
        )
        cancel_button.pack(side="left", padx=5)
        
        # Save to Word button (explicit)
        self.save_word_button = ctk.CTkButton(
            buttons_frame,
            text="Save to Word",
            command=self._save_to_word,
            width=120,
            fg_color="#4a86e8",
            hover_color="#2d5bb9",
            font=ctk.CTkFont(weight="bold")
        )
        self.save_word_button.pack(side="right", padx=5)
        
        # Add button
        add_button = ctk.CTkButton(
            buttons_frame,
            text="Add to Collection",
            command=self._add_movie,
            width=180,
            font=ctk.CTkFont(weight="bold")
        )
        add_button.pack(side="right", padx=5)
        
    def _load_poster(self, url, frame):
        """Load movie poster from URL in a separate thread"""
        # Show loading indicator
        loading_label = ctk.CTkLabel(
            frame, 
            text="Loading poster...",
            font=ctk.CTkFont(size=14)
        )
        loading_label.place(relx=0.5, rely=0.5, anchor="center")
        
        def load_image():
            try:
                response = requests.get(url, timeout=10)
                img_data = BytesIO(response.content)
                img = Image.open(img_data)
                img = img.resize((240, 360), Image.LANCZOS)
                
                # Schedule the UI update on the main thread
                def update_ui():
                    try:
                        # Use CTkImage
                        ctk_img = ctk.CTkImage(light_image=img, dark_image=img, size=(240, 360))
                        
                        # Create label with CTkImage
                        img_label = ctk.CTkLabel(frame, text="", image=ctk_img)
                        img_label.place(relx=0.5, rely=0.5, anchor="center")
                        
                        # Keep a reference to prevent garbage collection
                        if not hasattr(frame, "_image_refs"):
                            frame._image_refs = []
                        frame._image_refs.append(ctk_img)
                    except Exception as e:
                        print(f"Error updating UI with image: {e}")
                
                # Schedule UI update on main thread
                self.after(0, update_ui)
                
            except Exception as e:
                print(f"Error loading image: {e}")
                
                # Schedule showing placeholder on main thread
                def show_placeholder():
                    try:
                        # Show placeholder on error
                        placeholder = ctk.CTkLabel(
                            frame, 
                            text="üé¨",
                            font=ctk.CTkFont(size=64)
                        )
                        placeholder.place(relx=0.5, rely=0.5, anchor="center")
                    except Exception as placeholder_error:
                        print(f"Error creating placeholder: {placeholder_error}")
                
                self.after(0, show_placeholder)
        
        # Start thread to load image
        threading.Thread(target=load_image).start()
        
    def _toggle_date_option(self):
        """Toggle between today and custom date entry"""
        if self.date_var.get() == "custom":
            self.date_entry.configure(state="normal")
            else:
            self.date_entry.configure(state="disabled")
    
    def _update_rating_label(self, value):
        """Update the rating label when slider is moved"""
        self.rating_label.configure(text=f"{value:.1f}")
    
    def _format_watch_date(self):
        """Format the watch date based on selection"""
        if self.date_var.get() == "today":
            return datetime.datetime.now().strftime("%b %d, %Y")
        else:
            # Get the date from DateEntry and format it
            date = self.date_entry.get_date()
            return date.strftime("%b %d, %Y")
    
    def _save_to_word(self):
        """Save movie details to Word document with correct field names matching the table"""
        try:
            # Get watch date and rating
            watch_date = self._format_watch_date()
            user_rating = self.rating_var.get()
            is_rewatch = self.rewatch_var.get() == "yes"
            
            # Format runtime properly (convert minutes to "Xh Ym" format)
            time_duration = ""
            if "runtime" in self.details and self.details["runtime"]:
                minutes = int(self.details["runtime"])
                hours = minutes // 60
                remaining_minutes = minutes % 60
                time_duration = f"{hours}h {remaining_minutes}m"
            
            # Format ratings consistently (X.X/10 for user/IMDb, Y% for RT)
            imdb_rating = ""
            if "imdb_rating" in self.details and self.details["imdb_rating"]:
                imdb_rating = f"{self.details['imdb_rating']}"
                if "/10" not in imdb_rating:
                    imdb_rating += "/10"
            
            rt_rating = ""
            if "rt_rating" in self.details and self.details["rt_rating"]:
                rt_rating = self.details["rt_rating"]
                if "%" not in rt_rating:
                    rt_rating += "%"
            
            # Prepare data for Word document with exact field names matching the table
            word_data = {
                # Main fields exactly as shown in the screenshot
                "title": self.movie.get("title", ""),  # Name column
                "duration": time_duration,  # TimeDuration column (2h 38m format)
                "genre": self.details.get("genres", ""),  # Genre column (Action/Sci-Fi format)
                "watch_date": watch_date,  # Watch date column
                "release_date": self.details.get("release_date", ""),  # Release date column 
                "user_rating": f"{user_rating:.1f}/10",  # Rating column (9.9/10 format)
                "imdb_rating": imdb_rating,  # IMDb rating column (8.8/10 format)
                "rt_rating": rt_rating,  # RT column (87% format)
                
                # Handle rewatch status
                "rewatch": "Rewatch" if is_rewatch else ""
            }
            
            # Add to Word document
            word_added = self.word_handler.add_movie(word_data)
            
            if word_added:
                self.saved_to_word = True
                self.word_handler.close_document(save=True)
                self.save_word_button.configure(
                    text="‚úì Saved to Word", 
                    state="disabled",
                    fg_color="green"
                )
                
                # Show confirmation message
                dialog = ctk.CTkInputDialog(
                    text="Successfully saved movie to Word document!",
                    title="Success"
                )
                dialog.get_input()
            else:
                # Show error
                dialog = ctk.CTkInputDialog(
                    text="Error saving to Word document. Please try again.",
                    title="Error"
                )
                dialog.get_input()
                
        except Exception as e:
            print(f"Error saving to Word: {e}")
            dialog = ctk.CTkInputDialog(
                text=f"Error saving to Word: {e}",
                title="Error"
            )
            dialog.get_input()
    
    def _add_movie(self):
        """Add the movie to the collection with comprehensive details"""
        try:
            # Get watch date and rating
            watch_date = self._format_watch_date()
            user_rating = self.rating_var.get()
            is_rewatch = self.rewatch_var.get() == "yes"
            
            # Create comprehensive movie data dictionary for local storage
            movie_data = {
                "title": self.movie.get("title", ""),
                "date_added": datetime.datetime.now().strftime("%Y-%m-%d"),
                "watch_date": watch_date,
                "user_rating": user_rating,
                "is_rewatch": is_rewatch
            }
            
            # Add poster path if available
            if self.movie.get("poster_path"):
                movie_data["poster"] = f"https://image.tmdb.org/t/p/w185{self.movie.get('poster_path')}"
            
            # Add year if available
            release_date = self.movie.get("release_date", "")
            if release_date and len(release_date) >= 4:
                try:
                    # Try to extract year from full date
                    year = int(release_date[:4])
                    movie_data["year"] = year
                except:
                    pass
            
            # Add comprehensive details if available
            if "runtime" in self.details:
                movie_data["runtime"] = self.details["runtime"]
            if "genres" in self.details:
                movie_data["genres"] = self.details["genres"]
            if "director" in self.details:
                movie_data["director"] = self.details["director"]
            if "release_date" in self.details:
                movie_data["release_date"] = self.details["release_date"]
            if "imdb_rating" in self.details and self.details["imdb_rating"]:
                try:
                    rating = float(self.details["imdb_rating"].replace("/10", ""))
                    movie_data["imdb_rating"] = rating
                except:
                    pass
            if "rt_rating" in self.details and self.details["rt_rating"]:
                try:
                    rating = float(self.details["rt_rating"].replace("%", ""))
                    movie_data["rt_rating"] = rating
                except:
                    pass
                    
            # Include additional comprehensive information
            if "cast" in self.details:
                movie_data["cast"] = self.details["cast"]
            if "overview" in self.movie:
                movie_data["overview"] = self.movie["overview"]
            if "tagline" in self.details:
                movie_data["tagline"] = self.details["tagline"]
            if "budget" in self.details:
                movie_data["budget"] = self.details["budget"]
            if "revenue" in self.details:
                movie_data["revenue"] = self.details["revenue"]
            if "production" in self.details:
                movie_data["production"] = self.details["production"]
            if "language" in self.details:
                movie_data["language"] = self.details["language"]
            if "imdb_id" in self.details:
                movie_data["imdb_id"] = self.details["imdb_id"]
            
            # Save Word state
            movie_data["word_added"] = self.saved_to_word
                
            # Set result and close dialog
            self.result = movie_data
            self.destroy()
            
        except Exception as e:
            print(f"Error adding movie: {e}")
        dialog = ctk.CTkInputDialog(
                text=f"Error adding movie: {e}",
            title="Error"
        )
        dialog.get_input()
